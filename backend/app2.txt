from flask import Flask, jsonify, request, current_app
from flask_cors import CORS
from werkzeug.security import generate_password_hash, check_password_hash
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity, decode_token
import telnetlib
import configparser
from datetime import datetime, time, timedelta
import re
from sqlalchemy import text
from itsdangerous import URLSafeTimedSerializer
from flask_mail import Mail, Message

# Import models
from database import db
from database.user import Users
from database.backup import BackUpTag
from database.race import Race
from database.registration import Registration
from database.category import Category
from database.track import Track
from database.login import Login

from database.race_operations import setup_all_race_results_tables

# Load configuration from config.ini
config = configparser.ConfigParser()
config.read('config.ini')

# Initialize Flask application
app = Flask(__name__, static_folder="static", template_folder="templates")
CORS(app, resources={r"/api/*": {"origins": ["http://localhost:3000"], "supports_credentials": True}})

# Initialize database
app.config['SQLALCHEMY_DATABASE_URI'] = config.get('database', 'DATABASE_URL')
app.config['SECRET_KEY'] = 'secret_key_here'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db.init_app(app)

# Inicializace JWT
jwt = JWTManager(app)
app.config['JWT_TOKEN_LOCATION'] = ['headers']
app.config['JWT_HEADER_NAME'] = 'Authorization'
app.config['JWT_HEADER_TYPE'] = 'Bearer'

# Initialize Mail
mail = Mail()
app.config['MAIL_SERVER'] = config.get('mail', 'MAIL_SERVER', fallback='smtp.gmail.com')
app.config['MAIL_PORT'] = config.getint('mail', 'MAIL_PORT', fallback=587)
app.config['MAIL_USE_TLS'] = config.getboolean('mail', 'MAIL_USE_TLS', fallback=True)
app.config['MAIL_USERNAME'] = config.get('mail', 'MAIL_USERNAME', fallback='your-email@gmail.com')
app.config['MAIL_PASSWORD'] = config.get('mail', 'MAIL_PASSWORD', fallback='your-app-password')
mail.init_app(app)

# Password reset configuration
TOKEN_EXPIRY = 1800
app.config['PASSWORD_RESET_SALT'] = config.get('security', 'PASSWORD_RESET_SALT', fallback='password-reset-salt')
reset_requests = {}

# Get the RFID configuration
hostname = config.get('alien_rfid', 'hostname')
port = config.getint('alien_rfid', 'port')

# RFID reader connection state
class AlienRFID:
    def __init__(self, hostname, port):
        self.hostname = hostname
        self.port = port
        self.terminal = None
        self.connected = False

    def connect(self):
        self.terminal = telnetlib.Telnet(self.hostname, self.port)
        self.terminal.read_until(b'Username>', timeout=3)
        self.terminal.write(b'alien\n')
        self.terminal.read_until(b'Password>', timeout=3)
        self.terminal.write(b'password\n')
        self.terminal.read_until(b'>', timeout=3)
        self.connected = True

    def disconnect(self):
        if self.connected and self.terminal:
            self.terminal.close()
            self.connected = False

    def command(self, cmd: str):
        if not self.connected:
            raise RuntimeError("Not connected to the RFID reader.")
        self.terminal.write(cmd.encode('utf-8') + b'\n')
        response = self.terminal.read_until(b'>', timeout=5)
        return response.decode('ascii')
    


alien = AlienRFID(hostname, port)

# Methods
@jwt.expired_token_loader
def expired_token_callback(jwt_header, jwt_payload):
    return jsonify({
        'msg': 'The token has expired',
        'error': 'token_expired'
    }), 401

@jwt.invalid_token_loader
def invalid_token_callback(error):
    return jsonify({
        'msg': 'Signature verification failed',
        'error': 'invalid_token'
    }), 401

@jwt.unauthorized_loader
def missing_token_callback(error):
    return jsonify({
        'msg': 'Request does not contain an access token',
        'error': 'authorization_required'
    }), 401

def get_category(gender, birth_year):
    """
    Get appropriate category based on gender and birth year from database
    """
    current_year = datetime.now().year
    age = current_year - birth_year

    categories = Category.query.filter_by(gender=gender).all()
    
    for category in categories:
        if category.min_age <= age <= category.max_age:
            return category.category_name

    return "Unknown Category"
    
def parse_tags(data):
    """Parse tag data from RFID reader response"""
    pattern = r"Tag:([\w\s]+), Disc:(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2}\.\d{3}), Last:(\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2}\.\d{3}), Count:(\d+), Ant:(\d+), Proto:(\d+)"
    tags_found = []
    
    for line in data.split('\n'):
        if not line.strip():
            continue
            
        match = re.match(pattern, line.strip())
        if match:
            try:
                tag_id, discovery_time, last_seen_time, count, ant, proto = match.groups()
                
                number = tag_id.strip().split()[-1]
                
                result = store_tags_to_database(
                    tag_id=tag_id.strip(),
                    number=int(number),
                    last_seen_time=last_seen_time
                )
                if result:
                    tags_found.append(result)
                    print(f'Successfully processed tag: {tag_id}')
            except Exception as e:
                print(f'Error processing line "{line}": {str(e)}')
        else:
            print(f'Line did not match pattern: {line}')
    
    return tags_found

def store_tags_to_database(tag_id, number, last_seen_time):
    """Store tag data in the database"""
    try:
        new_tag = BackUpTag(
            tag_id=tag_id,
            number=number,
            last_seen_time=last_seen_time
        )
        
        db.session.add(new_tag)
        db.session.commit()
        print(f'Stored new tag: {tag_id}')
        return new_tag
    
    except Exception as e:
        db.session.rollback()
        print(f'Error storing/updating tag {tag_id}: {str(e)}')
        raise

def parse_time_with_ms(time_str):
    """Parse time string with optional milliseconds"""
    if '.' in time_str:
        time_part, ms_part = time_str.split('.')
        ms_part = ms_part.ljust(3, '0')[:3]
        
    try:
        base_time = datetime.strptime(time_part, '%H:%M:%S').time()
        return time(base_time.hour, base_time.minute, base_time.second, 
                   int(ms_part) * 1000)
    except ValueError as e:
        raise ValueError(f"Invalid time format: {str(e)}")

def generate_reset_token(user_id):
    """Generate a timed token for password reset."""
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    return serializer.dumps(user_id, salt='password-reset-salt')

def verify_reset_token(token, expiration=1800):
    """Verify the reset token and return the user_id if valid."""
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        user_id = serializer.loads(
            token,
            salt='password-reset-salt',
            max_age=expiration
        )
        return user_id
    except:
        return None

def check_rate_limit(email):
    """Check if email has exceeded rate limit for password reset requests."""
    now = datetime.utcnow()
    if email in reset_requests:
        requests = [t for t in reset_requests[email] 
                   if now - t < timedelta(hours=1)]
        reset_requests[email] = requests
        if len(requests) >= 3:
            return False
    else:
        reset_requests[email] = []
    reset_requests[email].append(now)
    return True

def send_password_reset_email(email, reset_token):
    """Send password reset email with the reset token."""
    reset_url = f"http://localhost:3000/reset-password?token={reset_token}"
    
    msg = Message(
        'Password Reset Request',
        sender=current_app.config['MAIL_USERNAME'],
        recipients=[email]
    )
    
    msg.body = f'''To reset your password, visit the following link:
{reset_url}

If you did not make this request, please ignore this email.
The link will expire in 30 minutes.
'''
    
    mail.send(msg)

def validate_password(password):
    """
    Validate password strength.
    Returns (bool, str) tuple - (is_valid, error_message)
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long"
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter"
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter"
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number"
    return True, ""

# Routes
@app.route('/')
def index():
    return "Welcome to the RFID Reader API!", 200

@app.route('/api/connect', methods=['POST'])
def connect_reader():
    try:
        if alien.connected:
            alien.disconnect()
            alien.connected = False
            return jsonify({"status": "disconnected"})
        
        try:
            alien.connect()
            alien.connected = True
            return jsonify({"status": "connected"})
        
        except Exception as e:
            alien.connected = False
            return jsonify({
                "status": "error", 
                "message": str(e)
            }), 400
    
    except Exception as e:
        return jsonify({
            "status": "error", 
            "message": "Unexpected system error"
        }), 500

@app.route('/api/fetch_taglist', methods=['GET'])
def fetch_taglist():
    try:
        if not alien.connected:
            return jsonify({"status": "error", "message": "Not connected to RFID reader"})
        
        taglist_response = alien.command('get Taglist')
        parse_tags(taglist_response)
        print(taglist_response)
        tags = taglist_response.split("\n")
        middle_tags = tags[1:-1]
                    
        return jsonify({"status": "success", "taglist": middle_tags}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/registration', methods=['POST'])
def registration():
    try:
        data = request.json
        firstname = data.get('firstname')
        surname = data.get('surname')
        year = data.get('year')
        club = data.get('club')
        email = data.get('email')
        gender = data.get('gender')
        race_id = data.get('race_id')
        track_id = data.get('track_id')

        if not all([firstname, surname, year, club, email, gender, race_id, track_id]):
            return jsonify({'error': 'All fields are required'}), 400

        try:
            year = int(year)
            race_id = int(race_id)
            track_id = int(track_id)
        except ValueError:
            return jsonify({'error': 'Year, race_id, and track_id must be numbers'}), 400

        race = Race.query.get(race_id)
        track = Track.query.get(track_id)
        
        if not race or not track or track.race_id != race_id:
            return jsonify({'error': 'Invalid race or track selection'}), 404

        current_year = datetime.now().year
        user_age = current_year - year

        if user_age < track.min_age or user_age > track.max_age:
            return jsonify({
                'error': f'Age not eligible for this track. Must be between {track.min_age} and {track.max_age} years old.'
            }), 400
        
        category = Category.query.filter(
            Category.track_id == track_id,
            Category.min_age <= user_age,
            Category.max_age >= user_age,
            Category.gender == gender
        ).first()
        
        if not category:
            return jsonify({
                'error': 'No suitable category found for this user'
            }), 400

        user = Users(
            firstname=firstname,
            surname=surname,
            year=year,
            club=club,
            email=email,
            gender=gender
        )
        db.session.add(user)
        db.session.commit()

        registration = Registration(
            user_id=user.id,
            track_id=track_id,
            race_id=race_id,
            registration_time=datetime.now() + timedelta(hours=1)
        )
        db.session.add(registration)
        db.session.commit()

        return jsonify({
            'message': 'User successfully registered', 
            'registration_id': registration.id,
            'category_name': category.category_name
        }), 201

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'Error registering user: {str(e)}'}), 500
    
@app.route('/api/tags', methods=['GET'])
def get_tags():
    """Get all stored tags from database"""
    try:
        tags = BackUpTag.query.all()
        tags_list = []
        for tag in tags:
            tags_list.append({
                'tag_id': tag.tag_id,
                'number': tag.number,
                'last_seen_time': tag.last_seen_time,
                'count': tag.count,
                'antenna': tag.antenna,
                'protocol': tag.protocol
            })
        return jsonify({'tags': tags_list}), 200
    except Exception as e:
        return jsonify({'error': 'Error fetching tags'}), 500

@app.route('/api/store_results', methods=['POST'])
def store_results():

    
@app.route('/api/manual_result_store', methods=['POST'])
def manual_result_store():


@app.route('/api/categories', methods=['GET'])
def get_categories():


@app.route('/api/races', methods=['GET'])
def get_races():


@app.route('/api/race/add', methods=['POST'])
def add_race():


@app.route('/api/race/<int:race_id>/update', methods=['PUT'])
def update_race(race_id):


@app.route('/api/tracks', methods=['GET'])
def get_tracks():

    
@app.route('/api/race/<int:race_id>', methods=['GET'])
def get_race_detail(race_id):

    
@app.route('/api/set_track_start_time', methods=['POST'])
def set_track_start_time():

    
@app.route('/api/confirm_lineup', methods=['POST'])
def confirm_lineup():

    
@app.route('/api/race/<int:race_id>/results', methods=['GET'])
def get_race_results(race_id):

    
@app.route('/api/race/<int:race_id>/results/by-category', methods=['GET'])
def get_race_results_by_category(race_id):


@app.route('/api/race/<int:race_id>/results/by-track', methods=['GET'])
def get_race_results_by_track(race_id):

    
@app.route('/api/race/<int:race_id>/racer/<int:number>/laps', methods=['GET'])
def get_runner_laps(race_id, number):


@app.route('/api/race/<int:race_id>/result/update', methods=['POST'])
def update_race_result(race_id):

    
@app.route('/api/race/<int:race_id>/lap/update', methods=['POST'])
def update_lap_time(race_id):

    
@app.route('/api/race/<int:race_id>/lap/delete', methods=['POST'])
def delete_lap(race_id):

    
@app.route('/api/race/<int:race_id>/lap/add', methods=['POST'])
def add_manual_lap(race_id):

    
@app.route('/api/race/<int:race_id>/startlist', methods=['GET'])
def get_race_startlist(race_id):


@app.route('/api/race/<int:race_id>/startlist/update/user', methods=['POST'])
def update_startlist_user(race_id):


@app.route('/api/race/<int:race_id>/startlist/update/registration', methods=['POST'])
def update_startlist_registration(race_id):

        return jsonify({'error': f'Error updating registration: {str(e)}'}), 500

@app.route('/api/race/<int:race_id>/startlist/delete/<int:registration_id>', methods=['DELETE'])
def delete_registration(race_id, registration_id):


@app.route('/api/register', methods=['POST'])
def register():


@app.route('/api/login', methods=['POST'])
def login():


@app.route('/api/me', methods=['GET'])
@jwt_required()
def get_current_user():


@app.route('/api/forgot-password', methods=['POST'])
def forgot_password():


@app.route('/api/reset-password', methods=['POST'])
def reset_password():


@app.route('/api/me/registrations', methods=['GET'])


@app.route('/api/race/<race_id>/results/by-email/<email>', methods=['GET'])
def get_race_results_by_email(race_id, email):


@app.route('/<path:path>')
def catch_all(path):
    return app.send_static_file('index.html'), 200

def init_db():
    """Initialize database tables and create race results tables"""
    with app.app_context():
        db.create_all()
        setup_all_race_results_tables()

if __name__ == '__main__':
    init_db()
    app.run(host='0.0.0.0', port=5001, debug=True)
